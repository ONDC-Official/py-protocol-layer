# generated by datamodel-codegen:
#   filename:  v1_2_0.yaml
#   timestamp: 2023-06-20T15:01:25+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, BaseModel, EmailStr, Field, confloat, conint, constr


class Status(Enum):
    ACK = 'ACK'
    NACK = 'NACK'


class Ack(BaseModel):
    status: Status = Field(
        ...,
        description='Describe the status of the ACK response. If schema validation passes, status is ACK else it is NACK',
    )


class Address(BaseModel):
    door: Optional[str] = Field(None, description='Door / Shop number of the address')
    name: Optional[str] = Field(
        None, description='Name of address if applicable. Example, shop name'
    )
    building: Optional[str] = Field(None, description='Name of the building or block')
    street: Optional[str] = Field(None, description='Street name or number')
    locality: Optional[str] = Field(
        None, description='Name of the locality, apartments'
    )
    ward: Optional[str] = Field(
        None, description='Name or number of the ward if applicable'
    )
    city: Optional[str] = Field(None, description='City name')
    state: Optional[str] = Field(None, description='State name')
    country: Optional[str] = Field(None, description='Country name')
    area_code: Optional[str] = Field(
        None, description='Area code. This can be Pincode, ZIP code or any equivalent'
    )


class Authorization(BaseModel):
    type: Optional[str] = Field(
        None, description='Type of authorization mechanism used'
    )
    token: Optional[str] = Field(None, description='Token used for authorization')
    valid_from: Optional[datetime] = Field(
        None, description='Timestamp in RFC3339 format from which token is valid'
    )
    valid_to: Optional[datetime] = Field(
        None, description='Timestamp in RFC3339 format until which token is valid'
    )
    status: Optional[str] = Field(None, description='Status of the token')


class Type(Enum):
    full = 'full'
    partial = 'partial'


class City(BaseModel):
    name: Optional[str] = Field(None, description='Name of the city')
    code: Optional[str] = Field(
        None,
        description="Codification of city code will be using the std code of the city e.g. for Bengaluru, city code is 'std:080'",
    )


class Action(Enum):
    search = 'search'
    select = 'select'
    init = 'init'
    confirm = 'confirm'
    update = 'update'
    status = 'status'
    track = 'track'
    cancel = 'cancel'
    rating = 'rating'
    support = 'support'
    issue = 'issue'
    issue_status = 'issue_status'
    on_search = 'on_search'
    on_select = 'on_select'
    on_init = 'on_init'
    on_confirm = 'on_confirm'
    on_update = 'on_update'
    on_status = 'on_status'
    on_track = 'on_track'
    on_cancel = 'on_cancel'
    on_rating = 'on_rating'
    on_support = 'on_support'
    on_issue = 'on_issue'
    on_issue_status = 'on_issue_status'


class Country(BaseModel):
    name: Optional[str] = Field(None, description='Name of the country')
    code: Optional[str] = Field(
        None, description='Country code as per ISO 3166 Alpha-3 code format'
    )


class DecimalValue(BaseModel):
    __root__: Union[constr(regex=r'[+-]?([0-9]*[.])?[0-9]+'), float] = Field(
        ..., description='Describes a decimal value'
    )


class Document(BaseModel):
    url: Optional[AnyUrl] = None
    label: Optional[str] = None


class Domain(Enum):
    ONDC_RET10 = 'ONDC:RET10'
    ONDC_RET11 = 'ONDC:RET11'
    ONDC_RET12 = 'ONDC:RET12'
    ONDC_RET13 = 'ONDC:RET13'
    ONDC_RET14 = 'ONDC:RET14'
    ONDC_RET15 = 'ONDC:RET15'
    ONDC_RET16 = 'ONDC:RET16'
    ONDC_RET17 = 'ONDC:RET17'
    ONDC_RET18 = 'ONDC:RET18'
    ONDC_RET19 = 'ONDC:RET19'
    ONDC_RET20 = 'ONDC:RET20'
    ONDC_AGR10 = 'ONDC:AGR10'
    ONDC_MOB = 'ONDC:MOB'
    ONDC_LOG = 'ONDC:LOG'


class Duration(BaseModel):
    __root__: str = Field(..., description='Describes duration as per ISO8601 format')


class Type1(Enum):
    CONTEXT_ERROR = 'CONTEXT-ERROR'
    CORE_ERROR = 'CORE-ERROR'
    DOMAIN_ERROR = 'DOMAIN-ERROR'
    POLICY_ERROR = 'POLICY-ERROR'
    JSON_SCHEMA_ERROR = 'JSON-SCHEMA-ERROR'


class Error(BaseModel):
    type: Optional[Type1] = None
    code: str = Field(
        ...,
        description='ONDC specific error code. For full list of error codes, refer to docs/drafts/Error Codes.md of this repo',
    )
    path: Optional[str] = Field(
        None,
        description='Path to json schema generating the error. Used only during json schema validation errors',
    )
    message: Optional[str] = Field(
        None, description='Human readable message describing the error'
    )


class AnswerType(Enum):
    radio = 'radio'
    checkbox = 'checkbox'
    text = 'text'


class TlMethod(Enum):
    http_get = 'http/get'
    http_post = 'http/post'


class Params(BaseModel):
    feedback_id: str = Field(
        ...,
        description='This value will be placed in the the $feedback_id url param in case of http/get and in the requestBody http/post requests',
    )


class FeedbackUrl(BaseModel):
    url: Optional[AnyUrl] = Field(
        None, description='feedback URL sent by the Seller App'
    )
    tl_method: Optional[TlMethod] = None
    params: Optional[Params] = None


class Type2(Enum):
    Self_Pickup = 'Self-Pickup'
    Delivery = 'Delivery'
    Delivery_and_Self_Pickup = 'Delivery and Self-Pickup'
    Reverse_QC = 'Reverse QC'
    Cancel = 'Cancel'
    Return = 'Return'
    RTO = 'RTO'


class Gps(BaseModel):
    __root__: constr(
        regex=r'^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?),\s*[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$'
    ) = Field(..., description='Describes a gps coordinate')


class Image(BaseModel):
    __root__: str = Field(
        ...,
        description='Image of an object. <br/><br/> A url based image will look like <br/><br/>```uri:http://path/to/image``` <br/><br/> An image can also be sent as a data string. For example : <br/><br/> ```data:js87y34ilhriuho84r3i4```',
    )


class FieldOndcStatutoryReqsPackagedCommodities(BaseModel):
    manufacturer_or_packer_name: Optional[str] = Field(
        None,
        description='name of manufacturer or packer (in case manufacturer is not the packer) or name of importer for imported goods',
    )
    manufacturer_or_packer_address: Optional[str] = Field(
        None,
        description='address of manufacturer or packer (in case manufacturer is not the packer) or address of importer for imported goods',
    )
    common_or_generic_name_of_commodity: Optional[str] = Field(
        None, description='common or generic name of commodity'
    )
    multiple_products_name_number_or_qty: Optional[str] = Field(
        None,
        description='for packages with multiple products, the name and number of quantity of each (can be shown as "name1-number_or_quantity; name2-number_or_quantity..")',
    )
    net_quantity_or_measure_of_commodity_in_pkg: Optional[str] = Field(
        None,
        description='net quantity of commodity in terms of standard unit of weight or measure of commodity contained in package',
    )
    month_year_of_manufacture_packing_import: Optional[str] = Field(
        None, description='month and year of manufacture or packing or import'
    )
    imported_product_country_of_origin: Optional[str] = Field(
        None,
        description='country of origin for imported products (ISO 3166 Alpha-3 code format)',
    )
    contact_details_consumer_care: Optional[str] = Field(
        None,
        description='name, address, telephone no, email of person or office for contacting for consumer complaints (can be shown as name-"name of person or office; email-"email address";..)',
    )


class FieldOndcStatutoryReqsPrepackagedFood(BaseModel):
    ingredients_info: Optional[str] = Field(
        None,
        description='list of ingredients (except single ingredient foods), can be shown as ingredient (with percentage); ingredient (with percentage);..)<br> e.g. "Puffed Rice (40%); Split Green Gram (20%); Ground Nuts (20%);.."',
    )
    nutritional_info: Optional[str] = Field(
        None,
        description='nutritional info (can be shown as nutritional info (with unit, per standard unit, per serving);..)<br> e.g. "Energy(KCal) - (per 100kg) 420, (per serving 50g) 250; Protein(g) - (per 100kg) 12, (per serving 50g)6;.."',
    )
    additives_info: Optional[str] = Field(
        None,
        description='food additives together with specific name or recognized International Numbering System (can be shown as additive1-name or number;additive2-name or number;..)',
    )
    manufacturer_or_packer_name: Optional[str] = Field(
        None, description='name of manufacturer or packer (for non-retail containers)'
    )
    manufacturer_or_packer_address: Optional[str] = Field(
        None,
        description='address of manufacturer or packer (for non-retail containers)',
    )
    brand_owner_name: Optional[str] = Field(None, description='name of brand owner')
    brand_owner_address: Optional[str] = Field(
        None, description='address of brand owner'
    )
    brand_owner_FSSAI_logo: Optional[str] = Field(
        None,
        description='FSSAI logo of brand owner (url based image e.g. uri:http://path/to/image)',
    )
    brand_owner_FSSAI_license_no: Optional[str] = Field(
        None, description='FSSAI license no of brand owner'
    )
    other_FSSAI_license_no: Optional[str] = Field(
        None,
        description='FSSAI license no of manufacturer or marketer or packer or bottler if different from brand owner',
    )
    net_quantity: Optional[str] = Field(None, description='net quantity')
    importer_name: Optional[str] = Field(None, description='name of importer')
    importer_address: Optional[str] = Field(None, description='address of importer')
    importer_FSSAI_logo: Optional[str] = Field(
        None,
        description='FSSAI logo of importer (url based image e.g. uri:http://path/to/image)',
    )
    importer_FSSAI_license_no: Optional[str] = Field(
        None, description='FSSAI license no of importer'
    )
    imported_product_country_of_origin: Optional[str] = Field(
        None,
        description='country of origin for imported products (ISO 3166 Alpha-3 code format)',
    )
    other_importer_name: Optional[str] = Field(
        None,
        description='name of importer for product manufactured outside but packaged or bottled in India',
    )
    other_importer_address: Optional[str] = Field(
        None,
        description='address of importer for product manufactured outside but packaged or bottled in India',
    )
    other_premises: Optional[str] = Field(
        None,
        description='premises where product manufactured outside are packaged or bottled in India',
    )
    other_importer_country_of_origin: Optional[str] = Field(
        None,
        description='country of origin for product manufactured outside but packaged or bottled in India (ISO 3166 Alpha-3 code format)',
    )
    contact_details_consumer_care: Optional[str] = Field(
        None,
        description='name, address, telephone no, email of person or office for contacting for consumer complaints (can be shown as name-"name of person or office; email-"email address";..)',
    )


class Language(BaseModel):
    code: Optional[str] = None


class Name(BaseModel):
    __root__: str = Field(
        ...,
        description='Describes the name of a person in format: ./{given_name}/{honorific_prefix}/{first_name}/{middle_name}/{last_name}/{honorific_suffix}',
    )


class Experience(BaseModel):
    label: Optional[str] = None
    value: Optional[str] = None
    unit: Optional[str] = None


class State1(Enum):
    Created = 'Created'
    Accepted = 'Accepted'
    In_progress = 'In-progress'
    Completed = 'Completed'
    Cancelled = 'Cancelled'
    Packed = 'Packed'
    Out_for_delivery = 'Out-for-delivery'


class FieldOndcLinkedOrder(BaseModel):
    id: Optional[str] = None


class Organization(BaseModel):
    name: Optional[str] = None
    cred: Optional[str] = None


class Page(BaseModel):
    id: Optional[str] = None
    next_id: Optional[str] = None


class TlMethod1(Enum):
    http_get = 'http/get'
    http_post = 'http/post'
    payto = 'payto'
    upi = 'upi'


class Type3(Enum):
    ON_ORDER = 'ON-ORDER'
    PRE_FULFILLMENT = 'PRE-FULFILLMENT'
    ON_FULFILLMENT = 'ON-FULFILLMENT'
    POST_FULFILLMENT = 'POST-FULFILLMENT'


class Status1(Enum):
    PAID = 'PAID'
    NOT_PAID = 'NOT-PAID'
    PENDING = 'PENDING'


class CollectedBy(Enum):
    BAP = 'BAP'
    BPP = 'BPP'


class FieldOndcCollectedByStatus(Enum):
    Assert = 'Assert'
    Agree = 'Agree'
    Disagree = 'Disagree'
    Terminate = 'Terminate'


class FieldOndcBuyerAppFinderFeeType(Enum):
    Amount = 'Amount'
    Percent = 'Percent'


class FieldOndcWithholdingAmountStatus(Enum):
    Assert = 'Assert'
    Agree = 'Agree'
    Disagree = 'Disagree'
    Terminate = 'Terminate'


class FieldOndcReturnWindowStatus(Enum):
    Assert = 'Assert'
    Agree = 'Agree'
    Disagree = 'Disagree'
    Terminate = 'Terminate'


class FieldOndcSettlementBasis(Enum):
    Collection = 'Collection'
    Shipment = 'Shipment'
    Delivery = 'Delivery'


class FieldOndcSettlementBasisStatus(Enum):
    Assert = 'Assert'
    Agree = 'Agree'
    Disagree = 'Disagree'
    Terminate = 'Terminate'


class FieldOndcSettlementWindowStatus(Enum):
    Assert = 'Assert'
    Agree = 'Agree'
    Disagree = 'Disagree'
    Terminate = 'Terminate'


class SettlementCounterparty(Enum):
    buyer_app = 'buyer-app'
    seller_app = 'seller-app'
    logistics_provider = 'logistics-provider'


class SettlementPhase(Enum):
    sale_amount = 'sale-amount'
    withholding_amount = 'withholding-amount'


class SettlementType(Enum):
    neft = 'neft'
    rtgs = 'rtgs'
    upi = 'upi'


class SettlementStatus(Enum):
    PAID = 'PAID'
    NOT_PAID = 'NOT-PAID'


class FieldOndcSettlementDetail(BaseModel):
    settlement_counterparty: Optional[SettlementCounterparty] = None
    settlement_phase: Optional[SettlementPhase] = None
    settlement_type: Optional[SettlementType] = None
    settlement_bank_account_no: Optional[str] = None
    settlement_ifsc_code: Optional[str] = None
    upi_address: Optional[str] = Field(None, description='UPI payment address e.g. VPA')
    settlement_status: Optional[SettlementStatus] = None
    settlement_reference: Optional[str] = Field(
        None, description='Settlement transaction reference number'
    )
    settlement_timestamp: Optional[datetime] = Field(
        None, description='Settlement transaction timestamp'
    )


class Price(BaseModel):
    currency: str = Field(
        ..., description="ISO 4217 alphabetic currency code e.g. 'INR'"
    )
    value: DecimalValue
    estimated_value: Optional[DecimalValue] = None
    computed_value: Optional[DecimalValue] = None
    listed_value: Optional[DecimalValue] = None
    offered_value: Optional[DecimalValue] = None
    minimum_value: Optional[DecimalValue] = None
    maximum_value: Optional[DecimalValue] = None


class BreakupItem(BaseModel):
    title: Optional[str] = None
    price: Optional[Price] = None


class Quotation(BaseModel):
    price: Optional[Price] = None
    breakup: List[BreakupItem]
    ttl: Optional[Duration] = None


class Rateable(BaseModel):
    __root__: bool = Field(..., description='If the entity can be rated or not')


class RatingAck(BaseModel):
    feedback_ack: Optional[bool] = Field(
        None, description='If feedback has been recorded or not'
    )
    rating_ack: Optional[bool] = Field(
        None, description='If rating has been recorded or not'
    )


class Type4(Enum):
    CONSTANT = 'CONSTANT'
    VARIABLE = 'VARIABLE'


class Range(BaseModel):
    min: Optional[float] = None
    max: Optional[float] = None


class Scalar(BaseModel):
    type: Optional[Type4] = None
    value: Union[str, float]
    estimated_value: Optional[float] = None
    computed_value: Optional[float] = None
    range: Optional[Range] = None
    unit: str


class Schedule(BaseModel):
    frequency: Optional[Duration] = None
    holidays: Optional[List[str]] = None
    times: Optional[List[str]] = None


class Type5(Enum):
    bap = 'bap'
    bpp = 'bpp'
    bg = 'bg'


class Status2(Enum):
    INITIATED = 'INITIATED'
    UNDER_SUBSCRIPTION = 'UNDER_SUBSCRIPTION'
    SUBSCRIBED = 'SUBSCRIBED'
    INVALID_SSL = 'INVALID_SSL'
    UNSUBSCRIBED = 'UNSUBSCRIBED'


class Type6(Enum):
    order = 'order'
    billing = 'billing'
    fulfillment = 'fulfillment'


class Tags(BaseModel):
    __root__: Any = Field(
        ...,
        description='Describes a tag. This is a simple key-value store which is used to contain extended metadata',
    )


class TagChild(BaseModel):
    code: str
    value: str


class Tag(BaseModel):
    code: str
    list: List[TagChild]


class Range1(BaseModel):
    start: Optional[datetime] = None
    end: Optional[datetime] = None


class Time(BaseModel):
    label: Optional[str] = None
    timestamp: Optional[datetime] = None
    duration: Optional[Duration] = None
    range: Optional[Range1] = None
    days: Optional[str] = Field(
        None, description='comma separated values representing days of the week'
    )
    schedule: Optional[Schedule] = None


class Status3(Enum):
    active = 'active'
    inactive = 'inactive'
    Active = 'Active'


class Tracking(BaseModel):
    url: Optional[AnyUrl] = None
    status: Optional[Status3] = None


class Vehicle(BaseModel):
    category: Optional[str] = None
    capacity: Optional[int] = None
    make: Optional[str] = None
    model: Optional[str] = None
    size: Optional[str] = None
    variant: Optional[str] = None
    color: Optional[str] = None
    energy_type: Optional[str] = None
    registration: Optional[str] = None


class ActionTriggered(Enum):
    REFUND = 'REFUND'
    REPLACEMENT = 'REPLACEMENT'
    RETURN = 'RETURN'
    CANCEL = 'CANCEL'
    NO_ACTION = 'NO-ACTION'


class Action1(Enum):
    RESOLVE = 'RESOLVE'
    REJECT = 'REJECT'


class IssueResolution(BaseModel):
    short_desc: str = Field(..., description='resolution')
    long_desc: Optional[str] = Field(
        None, description='remarks of the resolution of the issue by the respondent'
    )
    gro_remarks: Optional[str] = Field(
        None, description='resolution remarks provided by the gro'
    )
    odr_remarks: Optional[str] = Field(
        None, description='remarks of the result of the dispute, if applicable'
    )
    action_triggered: ActionTriggered
    action: Optional[Action1] = Field(
        None,
        description='Indicactes the action taken while addressing the issue.\n ### Actions\n  1. resolve : indicating the issue being resolved. \n  2. reject : indicating that the issue is rejected by the respondent or the resolution provider. \n',
    )
    refund_amount: Optional[str] = None


class ResolutionSource(BaseModel):
    type: Optional[str] = None
    link: Optional[str] = None


class GroType(Enum):
    INTEFACING_NP_GRO = 'INTEFACING-NP-GRO'
    TRANSACTION_COUNTERPARTY_NP_GRO = 'TRANSACTION-COUNTERPARTY-NP-GRO'
    CASCADED_COUNTERPARTY_NP_GRO = 'CASCADED-COUNTERPARTY-NP-GRO'


class Faq(BaseModel):
    question: Optional[str] = None
    answer: Optional[str] = None


class IssueRating(BaseModel):
    value: str = Field(..., description='provided rating')


class IssueType(Enum):
    ISSUE = 'ISSUE'
    GRIEVANCE = 'GRIEVANCE'
    DISPUTE = 'DISPUTE'


class Status4(Enum):
    OPEN = 'OPEN'
    CLOSED = 'CLOSED'


class Rating1(Enum):
    THUMBS_UP = 'THUMBS-UP'
    THUMBS_DOWN = 'THUMBS-DOWN'


class Type7(Enum):
    CONSUMER = 'CONSUMER'
    SELLER = 'SELLER'
    INTERFACING_NP = 'INTERFACING-NP'


class IssueSource(BaseModel):
    network_participant_id: Optional[str] = Field(
        None,
        description='unique identifier of the network participant of the source of this issue. It can be one of buyer-id in the buyer- interfacing app , or any of the relevant network provider id based on what causes the issue',
    )
    type: Optional[Type7] = Field(
        None,
        description='Indicates the source from where the issue is raised. \n### TYPES\n    1. Consumer : indicating that the Consumer(Buyer) of a product or a service has raised the issue\n    2. Seller : indicating that the Seller of a product or a service has raised the issue\n    3. Intefacing NP : indicating that the Interfacing NP has identified and raised the issue\n',
    )


class IssueCategory(Enum):
    ORDER = 'ORDER'
    ITEM = 'ITEM'
    FULFILLMENT = 'FULFILLMENT'
    AGENT = 'AGENT'
    PAYMENT = 'PAYMENT'
    TRANSACTION = 'TRANSACTION'


class IssueSubCategory(Enum):
    ORD01 = 'ORD01'
    ORD02 = 'ORD02'
    ORD03 = 'ORD03'
    ITM01 = 'ITM01'
    ITM02 = 'ITM02'
    ITM03 = 'ITM03'
    ITM04 = 'ITM04'
    ITM05 = 'ITM05'
    FLM01 = 'FLM01'
    FLM02 = 'FLM02'
    FLM03 = 'FLM03'
    FLM04 = 'FLM04'
    FLM05 = 'FLM05'
    FLM06 = 'FLM06'
    FLM07 = 'FLM07'
    FLM08 = 'FLM08'
    AGT01 = 'AGT01'
    AGT02 = 'AGT02'
    PMT01 = 'PMT01'
    PMT02 = 'PMT02'
    PMT03 = 'PMT03'
    PMT04 = 'PMT04'


class IssueItem(BaseModel):
    id: Optional[str] = None
    quantity: Optional[float] = None


class IssueFulfillment(BaseModel):
    id: Optional[str] = None
    state: Optional[str] = None


class ComplainantAction1(Enum):
    OPEN = 'OPEN'
    ESCALATE = 'ESCALATE'
    CLOSE = 'CLOSE'


class RespondentAction1(Enum):
    PROCESSING = 'PROCESSING'
    CASCADED = 'CASCADED'
    RESOLVED = 'RESOLVED'
    NEED_MORE_INFO = 'NEED-MORE-INFO'


class Code1(BaseModel):
    __root__: str = Field(
        ..., description='Country code as per ISO 3166-1 and ISO 3166-2 format'
    )


class Code11(BaseModel):
    __root__: str = Field(..., description='City code')


class Organization1(BaseModel):
    name: Optional[str] = None
    cred: Optional[str] = None


class Contact1(BaseModel):
    name: Optional[Name] = None
    address: Optional[Address] = None
    phone: str
    email: str
    jcard: Optional[Dict[str, Any]] = Field(
        None,
        description='A Jcard object as per draft-ietf-jcardcal-jcard-03 specification',
    )
    tags: Optional[Tags] = None


class MediaFile(BaseModel):
    mimetype: Optional[str] = Field(
        None,
        description="indicates the nature and format of the document, file, or assortment of bytes. MIME types are defined and standardized in IETF's RFC 6838",
    )
    url: Optional[AnyUrl] = Field(None, description='The URL of the file')
    signature: Optional[str] = Field(
        None, description='The digital signature of the file signed by the sender'
    )
    dsa: Optional[str] = Field(
        None, description='The signing algorithm used by the sender'
    )


class IssueStatusMessage(BaseModel):
    issue_id: UUID = Field(
        ...,
        description='Network issue identifier is a unique number assigned to a complaint by the interfacing application',
    )


class Type8(Enum):
    INTERFACING_NP = 'INTERFACING-NP'
    TRANSACTION_COUNTERPARTY_NP = 'TRANSACTION-COUNTERPARTY-NP'
    CASCADED_COUNTERPARTY_NP = 'CASCADED-COUNTERPARTY-NP'


class ODRPricingModel(BaseModel):
    price: Optional[Price] = None
    pricing_info: Optional[str] = Field(
        None, description='addtional information about the pricing model'
    )


class CredentialCredentialSubject(BaseModel):
    id: Optional[str] = None
    additionalProperties: Optional[Dict[str, Any]] = None


class CredentialCredentialSchema(BaseModel):
    id: Optional[str] = None
    type: Optional[str] = None


class ContentType(Enum):
    text_plain = 'text/plain'
    text_html = 'text/html'
    application_json = 'application/json'


class DescriptorAdditionalDesc(BaseModel):
    url: Optional[str] = None
    content_type: Optional[ContentType] = None


class TimeRange(BaseModel):
    start: Optional[datetime] = None
    end: Optional[datetime] = None


class InlineResponse200Message(BaseModel):
    ack: Ack


class Id(BaseModel):
    __root__: str = Field(
        ...,
        description='ID of the add-on. This follows the syntax {item.id}/add-on/{add-on unique id} for item specific add-on OR ',
    )


class IdModel(BaseModel):
    __root__: Union[str, int] = Field(..., description='Unique id of the category')


class Code(BaseModel):
    __root__: str = Field(
        ...,
        description="Codification of city code will be using the std code of the city e.g. for Bengaluru, city code is 'std:080'",
    )


class CodeModel(BaseModel):
    __root__: str = Field(
        ..., description='Country code as per ISO 3166 Alpha-3 code format'
    )


class IdModel1(BaseModel):
    __root__: str


class FeedbackId(BaseModel):
    __root__: str = Field(
        ...,
        description='This value will be placed in the the $feedback_id url param in case of http/get and in the requestBody http/post requests',
    )


class IdModel2(BaseModel):
    __root__: str = Field(
        ..., description='Unique reference ID to the fulfillment of an order'
    )


class IdModel3(BaseModel):
    __root__: Union[str, int] = Field(
        ...,
        description='This is the most unique identifier of a service item. An example of an Item ID could be the SKU of a product.',
    )


class Selected(BaseModel):
    count: Union[str, conint(ge=0)]
    measure: Optional[Scalar] = None


class IdModel4(BaseModel):
    __root__: str


class Currency(BaseModel):
    __root__: str = Field(
        ..., description="ISO 4217 alphabetic currency code e.g. 'INR'"
    )


class Value(BaseModel):
    __root__: DecimalValue


class IdModel5(BaseModel):
    __root__: Union[str, int] = Field(..., description='Id of the provider')


class ValueModel(BaseModel):
    __root__: confloat(ge=1.0, le=5.0) = Field(
        ...,
        description='Rating value given to the object (1 - Poor; 2 - Needs improvement; 3 - Satisfactory; 4 - Good; 5 - Excellent)',
    )


class Billing(BaseModel):
    name: str = Field(
        ..., description='Personal details of the customer needed for billing.'
    )
    organization: Optional[Organization] = None
    address: Optional[Address] = None
    email: Optional[EmailStr] = None
    phone: str
    time: Optional[Time] = None
    tax_number: Optional[str] = Field(None, description='GST number')
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class SelectedReason(BaseModel):
    id: Optional[IdModel4] = None


class Circle(BaseModel):
    gps: Gps
    radius: Scalar


class Contact(BaseModel):
    phone: Optional[str] = None
    email: Optional[str] = None
    tags: Optional[Tags] = None


class Context(BaseModel):
    domain: Domain
    country: CodeModel
    city: Code
    action: Action = Field(
        ...,
        description='Defines the ONDC API call. Any actions other than the enumerated actions are not supported by ONDC Protocol',
    )
    core_version: str = Field(
        ..., description='Version of ONDC core API specification being used'
    )
    bap_id: str = Field(
        ...,
        description='Unique id of the Buyer App. By default it is the fully qualified domain name of the Buyer App',
    )
    bap_uri: str = Field(
        ...,
        description='URI of the Buyer App for accepting callbacks. Must have the same domain name as the bap_id',
    )
    bpp_id: Optional[str] = Field(
        None,
        description='Unique id of the Seller App. By default it is the fully qualified domain name of the Seller App',
    )
    bpp_uri: Optional[str] = Field(
        None,
        description='URI of the Seller App. Must have the same domain name as the bap_id',
    )
    transaction_id: str = Field(
        ...,
        description='This is a unique value which persists across all API calls from search through confirm',
    )
    message_id: str = Field(
        ...,
        description='This is a unique value which persists during a request / callback cycle',
    )
    timestamp: datetime = Field(
        ..., description='Time of request generation in RFC3339 format'
    )
    key: Optional[str] = Field(
        None, description='The encryption public key of the sender'
    )
    ttl: Optional[Union[str, int]] = Field(
        None,
        description="Timestamp for which this message holds valid in ISO8601 durations format<br> Outer limit for ttl for search, select, init, confirm, status, track, cancel, update, rating, support is 'PT30S' which is 30 seconds<br> Different buyer apps can change this to meet their UX requirements, but it shouldn't exceed this outer limit",
    )


class Descriptor(BaseModel):
    name: Optional[str] = None
    code: Optional[str] = None
    symbol: Optional[str] = None
    short_desc: Optional[str] = None
    long_desc: Optional[str] = None
    additional_desc: Optional[DescriptorAdditionalDesc] = None
    media: Optional[List[MediaFile]] = None
    images: Optional[List[Image]] = None
    audio: Optional[AnyUrl] = None
    field_3d_render: Optional[AnyUrl] = Field(None, alias='3d_render')


class Descriptor2(Descriptor):
    images: List[Image]


class Dimensions(BaseModel):
    length: Optional[Scalar] = None
    breadth: Optional[Scalar] = None
    height: Optional[Scalar] = None


class FeedbackFormElement(BaseModel):
    id: Optional[str] = None
    parent_id: Optional[IdModel1] = None
    question: Optional[str] = Field(
        None,
        description='Specifies the question to which the answer options will be contained in the child FeedbackFormElements',
    )
    answer: Optional[str] = Field(
        None,
        description='Specifies an answer option to which the question will be in the FeedbackFormElement specified in parent_id',
    )
    answer_type: Optional[AnswerType] = Field(
        None, description='Specifies how the answer option should be rendered.'
    )


class Allocated(BaseModel):
    count: Union[str, conint(ge=0)]
    measure: Optional[Scalar] = None


class Available(BaseModel):
    count: Union[str, conint(ge=0)]
    measure: Optional[Scalar] = None


class Maximum(BaseModel):
    count: Union[str, conint(ge=1)]
    measure: Optional[Scalar] = None


class Minimum(BaseModel):
    count: Union[str, conint(ge=0)]
    measure: Optional[Scalar] = None


class ItemQuantity(BaseModel):
    allocated: Optional[Allocated] = None
    available: Optional[Available] = None
    maximum: Optional[Maximum] = None
    minimum: Optional[Minimum] = None
    selected: Optional[Selected] = None

class Item(BaseModel):
    id: Union[str, int] = Field(
        ...,
        description='This is the most unique identifier of a service item. An example of an Item ID could be the SKU of a product.',
    )
    parent_item_id: Optional[IdModel3] = None
    descriptor: Optional[Descriptor] = None
    price: Optional[Price] = None
    category_id: Optional[IdModel] = None
    category_ids: Optional[List[constr(regex=r'^\w+:\d+$')]] = []
    fulfillment_id: Optional[IdModel2] = None
    rating: Optional[ValueModel] = None
    location_id: Optional[IdModel4] = None
    time: Optional[Time] = None
    rateable: Optional[Rateable] = None
    matched: Optional[bool] = None
    related: Optional[bool] = None
    recommended: Optional[bool] = None
    field__ondc_returnable: Optional[bool] = Field(
        None, alias='./ondc-returnable', description='whether the item is returnable'
    )
    field__ondc_seller_pickup_return: Optional[bool] = Field(
        None,
        alias='./ondc-seller_pickup_return',
        description='in case of return, whether the item should be picked up by seller',
    )
    field__ondc_return_window: Optional[str] = Field(
        None,
        alias='./ondc-return_window',
        description="return window for the item in ISO8601 durations format e.g. 'PT24H' indicates 24 hour return window",
    )
    field__ondc_cancellable: Optional[bool] = Field(
        None, alias='./ondc-cancellable', description='whether the item is cancellable'
    )
    field__ondc_time_to_ship: Optional[str] = Field(
        None,
        alias='./ondc-time_to_ship',
        description="time from order confirmation by which item ready to ship in ISO8601 durations format e.g. 'PT2H' indicates item ready to ship in 2 hrs",
    )
    field__ondc_available_on_cod: Optional[bool] = Field(
        None,
        alias='./ondc-available_on_cod',
        description='whether the catalog item is available on COD',
    )
    field__ondc_statutory_reqs_packaged_commodities: Optional[
        FieldOndcStatutoryReqsPackagedCommodities
    ] = Field(
        None,
        alias='./ondc-statutory_reqs_packaged_commodities',
        description='<br> mandatory attributes include the following<br> common_or_generic_name_of_commodity<br> net_quantity_or_measure_of_commodity_in_pkg<br> month_year_of_manufacture_packing_import<br> contact_details_consumer_care<br>',
    )
    field__ondc_statutory_reqs_prepackaged_food: Optional[
        FieldOndcStatutoryReqsPrepackagedFood
    ] = Field(
        None,
        alias='./ondc-statutory_reqs_prepackaged_food',
        description='<br> mandatory attributes include the following<br> ingredients_info<br> nutritional_info<br> additives_info<br> net_quantity<br> contact_details_consumer_care<br>',
    )
    tags: List[Tag] = []


class Location(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None
    gps: Optional[Gps] = None
    address: Optional[Address] = None
    station_code: Optional[str] = None
    city: Optional[City] = None
    country: Optional[Country] = None
    circle: Optional[Circle] = None
    polygon: Optional[str] = None
    field_3dspace: Optional[str] = Field(None, alias='3dspace')
    time: Optional[Time] = None


class Offer(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None
    location_ids: Optional[List[IdModel4]] = None
    category_ids: Optional[List[IdModel]] = None
    item_ids: Optional[List[IdModel3]] = None
    time: Optional[Time] = None


class Option(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None


class Location1(BaseModel):
    id: IdModel4


class Provider1(BaseModel):
    id: Optional[IdModel5] = None
    locations: Optional[List[Location1]] = Field(None)


class Item1(BaseModel):
    id: IdModel3
    quantity: Optional[Selected] = None


class AddOn1(BaseModel):
    id: Id


class Offer1(BaseModel):
    id: IdModel4


class Params1(BaseModel):
    transaction_id: Optional[str] = Field(
        None,
        description='This value will be placed in the the $transaction_id url param in case of http/get and in the requestBody http/post requests',
    )
    transaction_status: Optional[str] = None
    amount: Optional[Value] = None
    currency: Optional[Currency] = None


class Payment(BaseModel):
    uri: Optional[AnyUrl] = Field(
        None,
        description='A payment uri to be called by the Buyer App. If empty, then the payment is to be done offline. The details of payment should be present in the params object. If ```tl_method``` = http/get, then the payment details will be sent as url params. Two url param values, ```$transaction_id``` and ```$amount``` are mandatory. And example url would be : https://www.example.com/pay?txid=$transaction_id&amount=$amount&vpa=upiid&payee=shopez&billno=1234',
    )
    tl_method: Optional[TlMethod1] = None
    params: Optional[Params1] = None
    type: Optional[Type3] = None
    status: Optional[Status1] = None
    time: Optional[Time] = None
    collected_by: Optional[CollectedBy] = None
    field__ondc_collected_by_status: Optional[FieldOndcCollectedByStatus] = Field(
        None, alias='./ondc-collected_by_status'
    )
    field__ondc_buyer_app_finder_fee_type: Optional[
        FieldOndcBuyerAppFinderFeeType
    ] = Field(None, alias='./ondc-buyer_app_finder_fee_type')
    field__ondc_buyer_app_finder_fee_amount: Optional[DecimalValue] = Field(
        None, alias='./ondc-buyer_app_finder_fee_amount'
    )
    field__ondc_withholding_amount: Optional[DecimalValue] = Field(
        None, alias='./ondc-withholding_amount'
    )
    field__ondc_withholding_amount_status: Optional[
        FieldOndcWithholdingAmountStatus
    ] = Field(None, alias='./ondc-withholding_amount_status')
    field__ondc_return_window: Optional[str] = Field(
        None,
        alias='./ondc-return_window',
        description="return window for the item in ISO8601 durations format e.g. 'PT24H' indicates 24 hour return window",
    )
    field__ondc_return_window_status: Optional[FieldOndcReturnWindowStatus] = Field(
        None, alias='./ondc-return_window_status'
    )
    field__ondc_settlement_basis: Optional[FieldOndcSettlementBasis] = Field(
        None,
        alias='./ondc-settlement_basis',
        description='In case of prepaid payment, whether settlement between counterparties should be on the basis of collection, shipment or delivery',
    )
    field__ondc_settlement_basis_status: Optional[
        FieldOndcSettlementBasisStatus
    ] = Field(None, alias='./ondc-settlement_basis_status')
    field__ondc_settlement_window: Optional[str] = Field(
        None,
        alias='./ondc-settlement_window',
        description="return window for the item in ISO8601 durations format e.g. 'PT24H' indicates 24 hour return window",
    )
    field__ondc_settlement_window_status: Optional[
        FieldOndcSettlementWindowStatus
    ] = Field(None, alias='./ondc-settlement_window_status')
    field__ondc_settlement_details: Optional[List[FieldOndcSettlementDetail]] = Field(
        None, alias='./ondc-settlement_details'
    )


class Person(BaseModel):
    name: Optional[Name] = None
    image: Optional[Image] = None
    dob: Optional[date] = None
    gender: Optional[str] = Field(
        None,
        description='Gender of something, typically a Person, but possibly also fictional characters, animals, etc. While Male and Female may be used, text strings are also acceptable for people who do not identify as a binary gender',
    )
    cred: Optional[str] = None
    tags: Optional[Tags] = None


class Policy(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None
    parent_policy_id: Optional[IdModel4] = None
    time: Optional[Time] = None


class Location2(Location):
    rateable: Optional[Rateable] = None


class Item2(Item):
    quantity: Optional[ItemQuantity] = None
    tags: List[Tag]


class OnSearchItem(Item):
    quantity: ItemQuantity
    tags: List[Tag]


class State(BaseModel):
    descriptor: Optional[Descriptor] = None
    updated_at: Optional[datetime] = None
    updated_by: Optional[str] = Field(
        None, description='ID of entity which changed the state'
    )


class Subscriber(BaseModel):
    subscriber_id: Optional[str] = Field(
        None,
        description='Registered domain name of the subscriber. Must have a valid SSL certificate issued by a Certificate Authority of the operating region',
    )
    type: Optional[Type5] = None
    cb_url: Optional[str] = Field(
        None,
        description="Callback URL of the subscriber. The Registry will call this URL's on_subscribe API to validate the subscriber\\'s credentials",
    )
    domain: Optional[Domain] = None
    city: Optional[Code] = None
    country: Optional[CodeModel] = None
    signing_public_key: Optional[str] = Field(
        None,
        description="Signing Public key of the subscriber. <br/><br/>Any subscriber platform (Buyer App, Seller App, Gateway) who wants to transact on the network must digitally sign the ```requestBody``` using the corresponding private key of this public key and send it in the transport layer header. In case of ```HTTP``` it is the ```Authorization``` header. <br><br/>The ```Authorization``` will be used to validate the signature of a Buyer App or Seller App.<br/><br/>Furthermore, if an API call is being proxied or multicast by a ONDC Gateway, the Gateway must use it\\'s signing key to digitally sign the ```requestBody``` using the corresponding private key of this public key and send it in the ```X-Gateway-Authorization``` header.",
    )
    encryption_public_key: Optional[str] = Field(
        None,
        description='Encryption public key of the Buyer App. Any Seller App must encrypt the ```requestBody.message``` value of the ```on_search``` API using this public key.',
    )
    status: Optional[Status2] = None
    created: Optional[datetime] = Field(
        None,
        description='Timestamp when a subscriber was added to the registry with status = INITIATED',
    )
    updated: Optional[datetime] = None
    expires: Optional[datetime] = Field(
        None,
        description='Expiry timestamp in UTC derived from the ```lease_time``` of the subscriber',
    )


class Support(BaseModel):
    type: Optional[Type6] = None
    ref_id: Optional[str] = None
    channels: Optional[Tags] = None


class TrackingData(BaseModel):
    __root__: Gps = Field(
        ...,
        description='Describes tracking data object during live tracking of an order',
    )


class Complainant(BaseModel):
    person: Optional[Person] = None
    contact: Contact


class IssueOrganization(BaseModel):
    org: Optional[Organization1] = None
    contact: Optional[Contact] = None
    person: Optional[Person] = None


class GRO(BaseModel):
    person: Optional[Person] = None
    contact: Optional[Contact1] = None
    gro_type: GroType = Field(
        ...,
        description='Indicates the system through which the GRO is assigned to this issue. \n### TYPES\n    1. Intefacing NP GRO : indicating the GRO is assigned by the NP where or through which the issue is raised\n    2. Transaction Counterparty NP GRO : indicating the GRO is assigned by the first level of counterparty network provider with which the interfacing NP is interacting with to get an issue resolution.\n    3. Cascaded Counterparty NP GRO : indicating the GRO is assigned by the second or any further downstream levels of counterparty network provider, with which the NP is interacting with, to get an issue resolution.\n',
    )


class ODR(BaseModel):
    name: str = Field(..., description='Name of the ODR provider')
    short_desc: str = Field(..., description='Information about the ODR provider')
    long_desc: Optional[str] = Field(
        None, description='Detailed information about the ODR provider'
    )
    url: str = Field(..., description='URL link to the ODR provider')
    organization: Optional[IssueOrganization] = None
    pricing_model: ODRPricingModel
    resolution_ratings: IssueRating


class SupplementaryInformation(BaseModel):
    issue_update_info: Optional[Descriptor] = None
    updated_at: Optional[datetime] = Field(
        None,
        description='timestamp for the capturing the time an issue was last updated',
    )
    message_id: Optional[str] = None


class OrderDetails(BaseModel):
    id: Optional[str] = Field(
        None,
        description='the value of this field will be the combination of context.transaction_id and order.id.',
    )
    state: Optional[str] = None
    items: Optional[List[IssueItem]] = None
    fulfillments: Optional[List[IssueFulfillment]] = None


class AdditionalInfoRequired(BaseModel):
    info_required: Optional[SupplementaryInformation] = None
    info_provided: Optional[SupplementaryInformation] = None


class SelectedODRs(BaseModel):
    respondent_info: Optional[IssueOrganization] = None
    odrs: Optional[List[ODR]] = None


class ComplainantAction(BaseModel):
    complainant_action: Optional[ComplainantAction1] = Field(
        None,
        description="Describes the action taken by the complainant who has raised the issue. \nthe value should be populated when the complainant has taken any of the below actions to anotate the action taken. the actions can be, \n### Actions\n1. Complainant can ```open``` the issue if he isn't satisfied with the products or services he has purchased or used \n2. Complainant can ```escalate``` the issue if he isn't satisfied with the issue resolution\n3. Complainant can ```close``` the issue if he doesn't expect any more additonal action on the issue and he is satisfied with the resolution/actions taken on the issue till the time of closure of the issue.\n",
    )
    updated_at: Optional[datetime] = Field(
        None,
        description='timestamp for the capturing the time an issue status was last updated',
    )
    updated_by: Optional[IssueOrganization] = None
    short_desc: Optional[str] = Field(
        None,
        description='details of the remarks when the issue status is changed, can be captured when the complainant triggers an action',
    )


class RespondentAction(BaseModel):
    respondent_action: Optional[RespondentAction1] = None
    updated_at: Optional[datetime] = Field(
        None,
        description='timestamp for the capturing the time an issue status was last updated',
    )
    updated_by: Optional[IssueOrganization] = None
    short_desc: Optional[str] = Field(
        None,
        description='details of the remarks when the issue status is changed, can be captured when the respondent triggers an action',
    )
    cascaded_level: Optional[int] = Field(
        None,
        description='the default value will be 1, whenever the issue will be cascaded to the next level the value of this field should be incremented by 1 it will upgrade it indicates to the next sub-level.',
    )


class Credential(BaseModel):
    id: Optional[str] = None
    type: Optional[str] = 'VerifiableCredential'
    issuer: Optional[str] = None
    issuance_date: Optional[datetime] = None
    credential_subject: Optional[CredentialCredentialSubject] = None
    credential_schema: Optional[CredentialCredentialSchema] = None


class InlineResponse200(BaseModel):
    message: InlineResponse200Message
    error: Optional[Error] = None


class IssueStatusBody(BaseModel):
    context: Context
    message: IssueStatusMessage


class AddOn(BaseModel):
    id: Optional[str] = Field(
        None,
        description='ID of the add-on. This follows the syntax {item.id}/add-on/{add-on unique id} for item specific add-on OR ',
    )
    descriptor: Optional[Descriptor] = None
    price: Optional[Price] = None


class Agent(Person, Contact):
    rateable: Optional[Rateable] = None


class Cancellation(BaseModel):
    type: Optional[Type] = None
    ref_id: Optional[str] = None
    policies: Optional[List[Policy]] = None
    time: Optional[datetime] = None
    cancelled_by: Optional[str] = None
    reasons: Optional[Option] = None
    selected_reason: Optional[SelectedReason] = None
    additional_description: Optional[Descriptor] = None


class Category(BaseModel):
    id: str
    parent_category_id: Optional[IdModel] = None
    descriptor: Optional[Descriptor] = None
    time: Optional[Time] = None
    tags: List[Tag] = []


class FeedbackForm(BaseModel):
    __root__: List[FeedbackFormElement] = Field(
        ...,
        description='Describes a feedback form that a Seller App can send to get feedback from the Buyer App',
    )


class Customer(BaseModel):
    person: Optional[Person] = None
    contact: Optional[Contact] = None


class Start(BaseModel):
    location: Optional[Location] = None
    time: Optional[Time] = None
    instructions: Optional[Descriptor] = None
    contact: Optional[Contact] = None
    person: Optional[Person] = None
    authorization: Optional[Authorization] = None


class End(BaseModel):
    location: Optional[Location] = None
    time: Optional[Time] = None
    instructions: Optional[Descriptor] = None
    contact: Optional[Contact] = None
    person: Optional[Person] = None
    authorization: Optional[Authorization] = None


class Fulfillment(BaseModel):
    id: Optional[str] = Field(
        None, description='Unique reference ID to the fulfillment of an order'
    )
    type: Optional[Type2] = Field(
        None,
        description='This describes the type of fulfillment ("Pickup" - Buyer picks up from store by themselves or through their logistics provider; "Delivery" - seller delivers to buyer)',
    )
    provider_id: Optional[IdModel5] = None
    rating: Optional[ValueModel] = None
    state: Optional[State] = None
    tracking: Optional[bool] = Field(
        False, description='Indicates whether the fulfillment allows tracking'
    )
    customer: Optional[Customer] = None
    agent: Optional[Agent] = None
    person: Optional[Person] = None
    contact: Optional[Contact] = None
    vehicle: Optional[Vehicle] = None
    start: Optional[Start] = Field(
        None, description='Details on the start of fulfillment'
    )
    end: Optional[End] = Field(None, description='Details on the end of fulfillment')
    rateable: Optional[Rateable] = None
    tags: List[Tag] = []


class Operator(Person):
    experience: Optional[Experience] = None


class Order(BaseModel):
    id: Optional[Union[float, str]] = Field(
        None,
        description='Hash of order object without id<br> Will be created by buyer app in confirm API',
    )
    state: Optional[State1] = None
    provider: Optional[Provider1] = None
    items: Optional[List[Item1]] = None
    add_ons: Optional[List[AddOn1]] = None
    offers: Optional[List[Offer1]] = None
    documents: Optional[List[Document]] = None
    billing: Optional[Billing] = None
    fulfillments: Optional[List[Fulfillment]] = None
    quote: Optional[Quotation] = None
    payment: Optional[Payment] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    field__ondc_cancellation: Optional[Cancellation] = Field(
        None, alias='./ondc-cancellation'
    )
    field__ondc_linked_orders: Optional[List[FieldOndcLinkedOrder]] = Field(
        None,
        alias='./ondc-linked_orders',
        description='payload for cascaded orders e.g. order for logistics services linked to a retail order',
    )


class Provider(BaseModel):
    id: Union[str, int] = Field(..., description='Id of the provider')
    descriptor: Optional[Descriptor] = None
    category_id: Optional[str] = Field(None, description='Category Id of the provider')
    rating: Optional[ValueModel] = None
    time: Optional[Time] = None
    categories: Optional[List[Category]] = None
    fulfillments: Optional[List[Fulfillment]] = None
    payments: Optional[List[Payment]] = None
    locations: Optional[List[Location2]] = None
    offers: Optional[List[Offer]] = None
    items: Optional[List[Item2]] = None
    exp: Optional[datetime] = Field(
        None, description='Time after which catalog has to be refreshed'
    )
    rateable: Optional[Rateable] = None
    tags: List[Tag] = []


class OnSearchProvider(BaseModel):
    id: Union[str, int] = Field(..., description='Id of the provider')
    descriptor: Optional[Descriptor] = None
    category_id: Optional[str] = Field(None, description='Category Id of the provider')
    rating: Optional[ValueModel] = None
    time: Optional[Time] = None
    categories: Optional[List[Category]] = None
    fulfillments: Optional[List[Fulfillment]] = None
    payments: Optional[List[Payment]] = None
    locations: Optional[List[Location2]] = None
    offers: Optional[List[Offer]] = None
    items: Optional[List[OnSearchItem]] = Field(None, description='Item List', max_items=500, min_items=1)
    exp: Optional[datetime] = Field(
        None, description='Time after which catalog has to be refreshed'
    )
    rateable: Optional[Rateable] = None
    tags: List[Tag]


class Rating(BaseModel):
    rating_category: Optional[str] = Field(
        None, description='Category of the object being rated'
    )
    id: Optional[str] = Field(None, description='Id of the object being rated')
    value: Optional[confloat(ge=1.0, le=5.0)] = Field(
        None,
        description='Rating value given to the object (1 - Poor; 2 - Needs improvement; 3 - Satisfactory; 4 - Good; 5 - Excellent)',
    )
    feedback_form: Optional[FeedbackForm] = None
    feedback_id: Optional[FeedbackId] = None


class ResolutionSupport(BaseModel):
    chat_link: Optional[str] = Field(
        None,
        description='chatbot link for the respondent for complainant to interact with the respondent',
    )
    contact: Optional[Contact] = None
    faqs: Optional[List[Faq]] = Field(
        None,
        description='frequently asked questions for the respondent for complainant to get information as required',
    )
    additional_sources: Optional[List[ResolutionSource]] = None
    gros: Optional[List[GRO]] = Field(
        None,
        description='Details of the GRO appointed by the resolution provider to support in issue resolution .\nThis is a required object if and when the issue type is "Grievance"\n',
    )


class IssueActions(BaseModel):
    complainant_actions: Optional[List[ComplainantAction]] = None
    respondent_actions: Optional[List[RespondentAction]] = None


class ResolutionProviderRespondentInfo(BaseModel):
    type: Optional[Type8] = Field(
        None,
        description='Indicates the type of the resolution provider NP type.\n### TYPES\n1. Interfacing NP : indicating the NP where or through which the issue is raised\n2. Transaction Counterparty NP : indicating the first level of transaction counterparty network provider with which the interfacing NP is interacting with to get an issue resolution.\n3. Cascaded Counterparty NP : indicating the second or any further downstream levels of counterparty network provider with which the NP is interacting with to get an issue resolution.\n',
    )
    organization: Optional[IssueOrganization] = None
    resolution_support: Optional[ResolutionSupport] = None


class Catalog(BaseModel):
    bpp_descriptor: Optional[Descriptor] = Field(None, alias='bpp/descriptor')
    bpp_categories: Optional[List[Category]] = Field(None, alias='bpp/categories')
    bpp_fulfillments: Optional[List[Fulfillment]] = Field(
        None, alias='bpp/fulfillments'
    )
    bpp_payments: Optional[List[Payment]] = Field(None, alias='bpp/payments')
    bpp_offers: Optional[List[Offer]] = Field(None, alias='bpp/offers')
    bpp_providers: List[OnSearchProvider] = Field(..., alias='bpp/providers', max_items=5, min_items=1)
    exp: Optional[datetime] = Field(
        None, description='Time after which catalog has to be refreshed'
    )


class Feedback(BaseModel):
    feedback_form: Optional[FeedbackForm] = None
    feedback_url: Optional[FeedbackUrl] = None


class ResolutionProvider(BaseModel):
    respondent_info: ResolutionProviderRespondentInfo


class Issue(BaseModel):
    id: UUID = Field(
        ...,
        description='* Network issue identifier is an unique number assigned to any complaint by the interfacing application at the source.\n\n* **During the life cycle of a complaint, this number will not change and will be communicated to counterparty application.**\n\n* Any subsequent issues created with the interfacing,counterpary or casacaded counter party apps are responsible for providing the correalted and relevant network-issue-id which helps all this inteacting systems to traverse back to the main issue.\n',
    )
    complainant_info: Optional[Complainant] = None
    order_details: Optional[OrderDetails] = None
    description: Optional[Descriptor] = None
    category: Optional[IssueCategory] = None
    sub_category: Optional[IssueSubCategory] = None
    issue_type: Optional[IssueType] = Field(
        None,
        description='identifies the type of the issue raised\n* the complainant being raised can be a regular ```Issue```, \n* which then subsequently can be escalated to be a ```Grievance``` \n* which may be further escalated to be a ```Dispute```\n',
    )
    source: Optional[IssueSource] = None
    expected_response_time: Optional[Time] = None
    expected_resolution_time: Optional[Time] = None
    status: Optional[Status4] = Field(
        None,
        description='### Statues\n  1. Open : indicating that the issue is opened and further action is yet to be taken on the issue\n  2. Closed : indicating that the issue is closed and no further action/update/info/resolution action/status change are expected/accepted on this issue. \n',
    )
    issue_actions: Optional[IssueActions] = None
    selected_odrs_info: Optional[List[SelectedODRs]] = Field(
        None,
        description='details of the ODRs selected by the resolution provider .\none of this would be subsequently finalized to be the ODR resposbile to resolve the issue . \nThis is a required object if and when the issue type is "Dispute"\n',
    )
    finalized_odr: Optional[ODR] = None
    rating: Optional[Rating1] = Field(
        None, description='rating by the complainant for issue resolution'
    )
    resolution_provider: Optional[ResolutionProvider] = None
    resolution: Optional[IssueResolution] = None
    additional_info_required: Optional[List[AdditionalInfoRequired]] = None
    created_at: datetime = Field(
        ..., description='timestamp for the creation of the issue'
    )
    updated_at: datetime = Field(
        ...,
        description='timestamp for the capturing the time an issue was last updated',
    )


class IssueMessage(BaseModel):
    issue: Optional[Issue] = None


class IssueBody(BaseModel):
    context: Context
    message: IssueMessage


class OnIssueMessage(BaseModel):
    issue: Issue


class OnIssueBody(BaseModel):
    context: Context
    message: OnIssueMessage
    error: Optional[Error] = None


class OnIssueStatusBody(BaseModel):
    context: Context
    message: IssueMessage
    error: Optional[Error] = None
